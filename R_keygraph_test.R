library(RMeCab)textdata <- "merosu.txt"# テキストデータ。ルート指定しないなら、Rのパス上に置く必要ある。文字コードUTF-8の改行コードLF。text <-  RMeCabFreq(textdata)# 読み込み、解析。頻度表を作成。head(text)text_temp <- text[text$Info1 =="名詞" & text$Info2 == "一般" |text$Info1 =="動詞" & text$Info2 == "自立" |text$Info1 =="形容詞" & text$Info2 == "自立",]# 抽出できた。抽出条件もひとまず。これで。text_temp <- text_temp[text_temp$Term!="する"&text_temp$Term!="いる"&text_temp$Term!="なる"&text_temp$Term !="ない"&text_temp$Term!="言う"&text_temp$Term!="ある"&text_temp$Term!="いい",]# 抽出ブラックリスト。するとか、なるとか。いるとか。ひとまず。text_freq <- tail(text_temp[order(text_temp$Freq),],n=20)# トップ20を抽出。tailはどうかと思うから後で変更。### order関数でなくrank関数の方が良いのでは？それなら、順番が1, 2.5, 2.5, 4, 5, 6, 7.5, 7.5, 9・・・って感じでソートされるので、x<9とか出来る。text_freq[,1]top_text_freq <- text_freq[,1]# top_text_freqは文字列ベクトル。top_text_freq[1]は文字。# 必要そうな情報 top_text_freqの数。length(top_text_freq)# for 1からlength(top_text_freq)までループ1word_n <- 0kyoukiG <- 0for (n in 1:length(top_text_freq)) {	word_n <- as.data.frame(collocate(textdata,node=top_text_freq[n],span=5)[c(T,F,F,T,F)])	print(top_text_freq[n])#	word_nはテキスト全部とある単語の共起度一覧。スパン5は変わらず。どうにかしないと。ココ。	word_m <- 0	#word_mをリセット	for (m in 1:length(top_text_freq)) {#		for 1からlength(top_text_freq)までループ2		word_meros <- word_n[word_n$Term==top_text_freq[m],]#		top_text_freq[m]を抽出word_meros関数を別の名前に		if(top_text_freq[n] == top_text_freq[m]){next}		if(length(word_meros$Span) == 0){next}#		ココでT,F判別。nとmが同じなら次のループへ。また、共起度あるなら下、次のループへ。長さ判別で0のやつをnextに持っていく。		word_m <- rbind(word_m,word_meros)#			word_merosをrbind関数でつなげる。全部！ぐるぐる共起度抽出回し祭りｷﾀ━(ﾟ∀ﾟ)━!	}#	ループ2ここまで	if(length(word_m) == 1){next}#	word_mに共起度が存在しない場合、次のループへ。	word_m$Term0<-top_text_freq[n]	#Term0を追加	word_m <- word_m[,c(3,1,2)]	#Term0 Term Spanの順番に#	グラフで描写出来るようにデータを整理。	kyoukiG <- rbind(kyoukiG,word_m)#	kyoukiG <- rbindでword_mをまた結合祭り。}# ループ1ここまでkyoukiGkyoukiGX <- 0for (n in 1:length(top_text_freq)) { 	print(top_text_freq[n])	kyoukiGX <- rbind(kyoukiG[kyoukiG$Term0 == top_text_freq[n],],kyoukiGX)	kyoukiG <- kyoukiG[kyoukiG$Term != top_text_freq[n] | kyoukiG$Term0 == top_text_freq[n],]}# メロスはメロスもあってメロスとセリヌンティウスとセリヌンティウスとメロスもあるんだから・・・？でも共起度が往復するだけだから大丈夫？うーん、igraphでテストデータ作ってみないことにはわからないかも。ダメだったら修正どうにか書ける必要がある。メロスとメロスなんかのやつは条件設定で抜けるはず？だめだった。重複は抜く。kyoukiG <- kyoukiGX[kyoukiGX$Span!=0,]# kyoukiGの条件=Spanが0の部分は除く。kyoukiG### これ、マトリクスに出来ないかな？###ここからKeyGraphのアルゴリズム作成開始。#### 共起グラフ用データセット作成！長かった！# グラフ作成 library(igraph)graphdata<-graph.data.frame(kyoukiG, directed = F)plot(graphdata, vertex.label=V(graphdata)$name)kyoukiG2 <- kyoukiG[kyoukiG$Span>1,]kyoukiG2graphdata2<-graph.data.frame(kyoukiG2, directed = F)plot(graphdata2, vertex.label=V(graphdata2)$name)