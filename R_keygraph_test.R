library(RMeCab)library(igraph)# 下準備textdata <- "kumo.txt"# テキストデータ。ルート指定しないなら、Rのパス上に置く必要ある。文字コードUTF-8の改行コードLF。M1 <- 30M2 <- 20M3 <- 10M4 <- 20M5 <- 20# M1-M5まだ意味なし関数。# データ洗浄text <-  RMeCabFreq(textdata)# 読み込み、解析。頻度表を作成。text_temp <- text[text$Info1 =="名詞" & text$Info2 == "一般" |text$Info1 =="動詞" & text$Info2 == "自立" |text$Info1 =="形容詞" & text$Info2 == "自立",]# 抽出できた。抽出条件もひとまず。これで。text_temp <- text_temp[text_temp$Term!="する"&text_temp$Term!="いる"&text_temp$Term!="なる"&text_temp$Term !="ない"&text_temp$Term!="言う"&text_temp$Term!="ある"&text_temp$Term!="いい",]# 抽出ブラックリスト。するとか、なるとか。いるとか。ひとまず。# 共起グラフの作成text_freq <- subset(text_temp,text_temp$Freq>=tail(sort(text_temp$Freq),n=M1)[1])# tail(text_temp[order(text_temp$Freq),],n=20)から変更。これで上位定数位より上を抽出可能に。# これがM1text_w <- text_temp[,1] # 橋の形成で使用。# トップ20を抽出。tailはどうかと思うから後で変更。### order関数でなくrank関数の方が良いのでは？それなら、順番が1, 2.5, 2.5, 4, 5, 6, 7.5, 7.5, 9・・・って感じでソートされるので、x<9とか出来る。text_freq[,1]top_text_freq <- text_freq[,1]# top_text_freqは文字列ベクトル。top_text_freq[1]は文字。# for 1からlength(top_text_freq)までループ1word_n <- 0kyoukiG <- 0for (n in 1:length(top_text_freq)) {	word_n <- as.data.frame(collocate(textdata,node=top_text_freq[n],span=5)[c(T,F,F,T,F)])	# print(top_text_freq[n])	# word_nはテキスト全部とある単語の共起度一覧。スパン5は変わらず。どうにかしないと。ココ。	word_m <- 0	# word_mをリセット	for (m in 1:length(top_text_freq)) {		# for 1からlength(top_text_freq)までループ2		word_meros <- word_n[word_n$Term==top_text_freq[m],]		# top_text_freq[m]を抽出word_meros関数を別の名前に		if(top_text_freq[n] == top_text_freq[m]){next}		if(length(word_meros$Span) == 0){next}		# ココでT,F判別。nとmが同じなら次のループへ。また、共起度あるなら下、次のループへ。長さ判別で0のやつをnextに持っていく。		word_m <- rbind(word_m,word_meros)		# word_merosをrbind関数でつなげる。全部！ぐるぐる共起度抽出回し祭りｷﾀ━(ﾟ∀ﾟ)━!	}	# ループ2ここまで	if(length(word_m) == 1){next}	# word_mに共起度が存在しない場合、次のループへ。	word_m$Term0<-top_text_freq[n]	# Term0を追加	word_m <- word_m[,c(3,1,2)]	# Term0 Term Spanの順番に	# グラフで描写出来るようにデータを整理。	kyoukiG <- rbind(kyoukiG,word_m)	# kyoukiG <- rbindでword_mをまた結合祭り。}# ループ1ここまでkyoukiGX <- 0for (n in 1:length(top_text_freq)) { 	kyoukiGX <- rbind(kyoukiG[kyoukiG$Term0 == top_text_freq[n],],kyoukiGX)	kyoukiG <- kyoukiG[kyoukiG$Term != top_text_freq[n] | kyoukiG$Term0 == top_text_freq[n],]}kyoukiG <- kyoukiGX[kyoukiGX$Span>0,]# メロスはメロスもあってメロスとセリヌンティウスとセリヌンティウスとメロスもあるんだから・・・？でも共起度が往復するだけだから大丈夫？うーん、igraphでテストデータ作ってみないことにはわからないかも。ダメだったら修正どうにか書ける必要がある。メロスとメロスなんかのやつは条件設定で抜けるはず？だめだった。重複は抜く。kyoukiG[order(kyoukiG$Span),]kyoukiG <- subset(kyoukiG,kyoukiG$Span>=tail(sort(kyoukiG$Span),n=M2)[1])# tail(kyoukiG[order(kyoukiG$Span),],n=20)# これがM2。kyoukiGgraphdata<-graph.data.frame(kyoukiG, directed = F)plot(graphdata, vertex.label=V(graphdata)$name)# 共起グラフをプロットしてみる。	# 単連結削除	for (n in 1:length(kyoukiG$Span)) { 	# ループ開始	kyoukiGX <- kyoukiG[kyoukiG$Term0 != kyoukiG[n,1] | kyoukiG$Term != kyoukiG[n,2],]	# まず、2つの線を外してみる	if(length(kyoukiGX[kyoukiGX$Term0 == kyoukiG[n,1]|kyoukiGX$Term == kyoukiG[n,1],]$Span)==0){		kyoukiG[kyoukiG$Term0 == kyoukiG[n,1]&kyoukiG$Term == kyoukiG[n,2],]$Span <- 0		next	}	if(length(kyoukiGX[kyoukiGX$Term0 == kyoukiG[n,2]|kyoukiGX$Term == kyoukiG[n,2],]$Span)==0){		kyoukiG[kyoukiG$Term0 == kyoukiG[n,1]&kyoukiG$Term == kyoukiG[n,2],]$Span <- 0		next	}	# 消した文章あるかどうか。つまり、どちらかが0ならそこの組み合わせの共起度を0にして、次へ。	graphdata<-graph.data.frame(kyoukiGX, directed = F)	# 変換。データ処理。	# plot(graphdata, vertex.label=V(graphdata)$name)	# ↑これ見てると面白い。	if(length(get.all.shortest.paths(graphdata,kyoukiG[n,1],to = kyoukiG[n,2])[[1]])==0){		kyoukiG[kyoukiG$Term0 == kyoukiG[n,1]&kyoukiG$Term == kyoukiG[n,2],]$Span <- 0		next	}	# 1:存在する 0:存在しない		# 道はあるかどうかなかったらそこの組み合わせの共起度を0にしてつぎへ。}kyoukiGX <- kyoukiG[kyoukiG$Span>0,]kyoukiGX# 島graphdata<-graph.data.frame(kyoukiGX, directed = F)plot(graphdata, vertex.label=V(graphdata)$name)# 単連結削除した共起グラフをプロットしてみる。	island_g <- union(kyoukiGX$Term0,kyoukiGX$Term)island_g# これが各島g# 橋の形成。# 島gとすべての単語wに対する共起度を測定。word_n <- 0kyoukiGW <- 0for (n in 1:length(island_g)) {	word_n <- as.data.frame(collocate(textdata,node=island_g[n],span=5)[c(T,F,F,T,F)])	# word_nはテキスト全部とある単語(島)の共起度一覧。スパン5は変わらず。どうにかしないと。ココ。	word_m <- 0	# word_mをリセット	for (m in 1:length(text_w)) {		# for 1からlength(text_w)までループ2		word_meros <- word_n[word_n$Term==text_w[m],]		# text_w[m]を抽出word_meros関数を別の名前に		if(island_g[n] == text_w[m]){next}		if(length(word_meros$Span) == 0){next}		# ココでT,F判別。nとmが同じなら次のループへ。また、共起度あるなら下、次のループへ。長さ判別で0のやつをnextに持っていく。		word_m <- rbind(word_m,word_meros)		# word_merosをrbind関数でつなげる。全部！ぐるぐる共起度抽出回し祭りｷﾀ━(ﾟ∀ﾟ)━!	}	# ループ2ここまで	if(length(word_m) == 1){next}	# word_mに共起度が存在しない場合、次のループへ。	word_m$Term0<-island_g[n]	# Term0を追加	word_m <- word_m[,c(3,1,2)]	# Term0 Term Spanの順番に	# グラフで描写出来るようにデータを整理。	kyoukiGW <- rbind(kyoukiGW,word_m)	# kyoukiGW <- rbindでword_mをまた結合祭り。}# ループ1ここまでkyoukiGWX <- 0for (n in 1:length(island_g)) { 	kyoukiGWX <- rbind(kyoukiGW[kyoukiGW$Term0 == island_g[n],],kyoukiGWX)	kyoukiGW <- kyoukiGW[kyoukiGW$Term != island_g[n] | kyoukiGW$Term0 == island_g[n],]}kyoukiGW <- kyoukiGWX[kyoukiGWX$Span>0,]# 重複を削除。kyoukiGW <- subset(kyoukiGW,kyoukiGW$Span>=tail(sort(kyoukiGW$Span),n=M3)[1])# tail(kyoukiGW[order(kyoukiGW$Span),],n=10)# これがM3の橋。kyoukiGWkyoukiGX# やっぱりマージはする必要あり。だって上位M3位のなかに島が入るとは限らない。graphdata<-graph.data.frame(kyoukiGW, directed = F)plot(graphdata, vertex.label=V(graphdata)$name)