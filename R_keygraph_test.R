library(RMeCab)library(igraph)# 下準備textdata <- "kumo.txt"# テキストデータ。ルート指定しないなら、Rのパス上に置く必要ある。文字コードUTF-8の改行コードLF。M1 <- 30M2 <- 20M3 <- 10M4 <- 20M5 <- 10# M1-M5まだ意味なし関数。# データ洗浄text <-  RMeCabFreq(textdata)# 読み込み、解析。頻度表を作成。text_temp <- text[text$Info1 =="名詞" & text$Info2 == "一般" |text$Info1 =="動詞" & text$Info2 == "自立" |text$Info1 =="形容詞" & text$Info2 == "自立",]# 抽出できた。抽出条件もひとまず。これで。text_temp <- text_temp[text_temp$Term!="する"&text_temp$Term!="いる"&text_temp$Term!="なる"&text_temp$Term !="ない"&text_temp$Term!="言う"&text_temp$Term!="ある"&text_temp$Term!="いい",]# 抽出ブラックリスト。するとか、なるとか。いるとか。ひとまず。# 共起グラフの作成text_freq <- subset(text_temp,text_temp$Freq>=tail(sort(text_temp$Freq),n=M1)[1])# tail(text_temp[order(text_temp$Freq),],n=20)から変更。これで上位定数位より上を抽出可能に。# これがM1text_w <- text_temp[,1] # 橋の形成で使用。text_freq[,1]top_text_freq <- text_freq[,1]# top_text_freqは文字列ベクトル。top_text_freq[1]は文字。# for 1からlength(top_text_freq)までループ1word_n <- 0kyoukiG <- 0for (n in 1:length(top_text_freq)) {	word_n <- as.data.frame(collocate(textdata,node=top_text_freq[n],span=5)[c(T,F,F,T,F)])	# print(top_text_freq[n])	# word_nはテキスト全部とある単語の共起度一覧。スパン5は変わらず。どうにかしないと。ココ。	word_m <- 0	# word_mをリセット	for (m in 1:length(top_text_freq)) {		# for 1からlength(top_text_freq)までループ2		word_meros <- word_n[word_n$Term==top_text_freq[m],]		# top_text_freq[m]を抽出word_meros関数を別の名前に		if(top_text_freq[n] == top_text_freq[m]){next}		if(length(word_meros$Span) == 0){next}		# ココでT,F判別。nとmが同じなら次のループへ。また、共起度あるなら下、次のループへ。長さ判別で0のやつをnextに持っていく。		word_m <- rbind(word_m,word_meros)		# word_merosをrbind関数でつなげる。	}	# ループ2ここまで	if(length(word_m) == 1){next}	# word_mに共起度が存在しない場合、次のループへ。	word_m$Term0<-top_text_freq[n]	# Term0を追加	word_m <- word_m[,c(3,1,2)]	# Term0 Term Spanの順番に	# グラフで描写出来るようにデータを整理。	kyoukiG <- rbind(kyoukiG,word_m)	# kyoukiG <- rbindでword_mをまた結合祭り。}# ループ1ここまでkyoukiGX <- 0for (n in 1:length(top_text_freq)) { 	kyoukiGX <- rbind(kyoukiG[kyoukiG$Term0 == top_text_freq[n],],kyoukiGX)	kyoukiG <- kyoukiG[kyoukiG$Term != top_text_freq[n] | kyoukiG$Term0 == top_text_freq[n],]}kyoukiG <- kyoukiGX[kyoukiGX$Span>0,]# 重複は抜く。kyoukiG[order(kyoukiG$Span),]kyoukiG <- subset(kyoukiG,kyoukiG$Span>=tail(sort(kyoukiG$Span),n=M2)[1])# tail(kyoukiG[order(kyoukiG$Span),],n=20)# これがM2。kyoukiGgraphdata_K<-graph.data.frame(kyoukiG, directed = F)plot(graphdata_K, vertex.label=V(graphdata_K)$name)# 共起グラフをプロットしてみる。# 単連結削除	for (n in 1:length(kyoukiG$Span)) { 	# ループ開始	kyoukiGX <- kyoukiG[kyoukiG$Term0 != kyoukiG[n,1] | kyoukiG$Term != kyoukiG[n,2],]	# まず、2つの線を外してみる	if(length(kyoukiGX[kyoukiGX$Term0 == kyoukiG[n,1]|kyoukiGX$Term == kyoukiG[n,1],]$Span)==0){		kyoukiG[kyoukiG$Term0 == kyoukiG[n,1]&kyoukiG$Term == kyoukiG[n,2],]$Span <- 0		next	}	if(length(kyoukiGX[kyoukiGX$Term0 == kyoukiG[n,2]|kyoukiGX$Term == kyoukiG[n,2],]$Span)==0){		kyoukiG[kyoukiG$Term0 == kyoukiG[n,1]&kyoukiG$Term == kyoukiG[n,2],]$Span <- 0		next	}	# 消した文章あるかどうか。つまり、どちらかが0ならそこの組み合わせの共起度を0にして、次へ。	graphdata<-graph.data.frame(kyoukiGX, directed = F)	# 変換。データ処理。	# plot(graphdata, vertex.label=V(graphdata)$name)	# ↑これ見てると面白い。	if(length(get.all.shortest.paths(graphdata,kyoukiG[n,1],to = kyoukiG[n,2])[[1]])==0){		kyoukiG[kyoukiG$Term0 == kyoukiG[n,1]&kyoukiG$Term == kyoukiG[n,2],]$Span <- 0		next	}	# 1:存在する 0:存在しない		# 道はあるかどうかなかったらそこの組み合わせの共起度を0にしてつぎへ。}kyoukiGX <- kyoukiG[kyoukiG$Span>0,]kyoukiGX# 島graphdata_T<-graph.data.frame(kyoukiGX, directed = F)plot(graphdata_T, vertex.label=V(graphdata_T)$name)# 単連結削除した共起グラフをプロットしてみる。	island_g <- union(kyoukiGX$Term0,kyoukiGX$Term)island_g# これが各島g# 橋の形成。# 島gとすべての単語wに対する共起度を測定。word_n <- 0kyoukiGW <- 0for (n in 1:length(island_g)) {	word_n <- as.data.frame(collocate(textdata,node=island_g[n],span=5)[c(T,F,F,T,F)])	# word_nはテキスト全部とある単語(島)の共起度一覧。スパン5は変わらず。どうにかしないと。ココ。	word_m <- 0	# word_mをリセット	for (m in 1:length(text_w)) {		# for 1からlength(text_w)までループ2		word_meros <- word_n[word_n$Term==text_w[m],]		# text_w[m]を抽出word_meros関数を別の名前に		if(island_g[n] == text_w[m]){next}		if(length(word_meros$Span) == 0){next}		# ココでT,F判別。nとmが同じなら次のループへ。また、共起度あるなら下、次のループへ。長さ判別で0のやつをnextに持っていく。		word_m <- rbind(word_m,word_meros)		# word_merosをrbind関数でつなげる。	}	# ループ2ここまで	if(length(word_m) == 1){next}	# word_mに共起度が存在しない場合、次のループへ。	word_m$Term0<-island_g[n]	# Term0を追加	word_m <- word_m[,c(3,1,2)]	# Term0 Term Spanの順番に	# グラフで描写出来るようにデータを整理。	kyoukiGW <- rbind(kyoukiGW,word_m)	# kyoukiGW <- rbindでword_mをまた結合祭り。}# ループ1ここまでkyoukiGWX <- 0for (n in 1:length(island_g)) { 	kyoukiGWX <- rbind(kyoukiGW[kyoukiGW$Term0 == island_g[n],],kyoukiGWX)	kyoukiGW <- kyoukiGW[kyoukiGW$Term != island_g[n] | kyoukiGW$Term0 == island_g[n],]}kyoukiGW <- kyoukiGWX[kyoukiGWX$Span>0,]# 重複を削除。kyoukiGW <- subset(kyoukiGW,kyoukiGW$Span>=tail(sort(kyoukiGW$Span),n=M3)[1])# tail(kyoukiGW[order(kyoukiGW$Span),],n=10)# これがM3の橋。kyoukiGXkyoukiGW# やっぱりマージはする必要あり。だって上位M3位のなかに島が入るとは限らない。まあ、それは後で。graphdata_I<-graph.data.frame(kyoukiGW, directed = F)plot(graphdata_I, vertex.label=V(graphdata_I)$name)# Key(w)作り。# 橋を介して w と結ばれる全ての島 g との共起度の和を Key(w) とする。item_w <- union(kyoukiGW$Term0,kyoukiGW$Term)item_w# これとすべての島island_gとの共起度を測定# n<-1Key_w <- data.frame(word="word",pro=0)for (n in 1:length(item_w)) { 	item_wX <- 0	pro_w <- 1	item_wX <- rbind(kyoukiGW[kyoukiGW$Term0 == item_w[n],] , kyoukiGW[kyoukiGW$Term == item_w[n],])	for(m in 1:length(island_g)) { 		# 各島		if(island_g[m] == item_w[n]){next}		if(length(item_wX[item_wX$Term0 == island_g[m],]$Span)==1){			probability_w <- 1 - item_wX[item_wX$Term0 == island_g[m],]$Span/text_temp[text_temp$Term == island_g[m],]$Freq			pro_w <- pro_w*probability_w		}		if(length(item_wX[item_wX$Term == island_g[m],]$Span)==1){			probability_w <- 1 - item_wX[item_wX$Term == island_g[m],]$Span/text_temp[text_temp$Term == island_g[m],]$Freq			pro_w <- pro_w*probability_w		}	}	pro_w <- 1- pro_w	key_wX <- data.frame(word=item_w[n],pro=pro_w)	Key_w <- rbind(Key_w,key_wX)}Key_w <- Key_w[Key_w$pro>0,]Key_wKey_w_G <- subset(Key_w,Key_w$pro>=tail(sort(Key_w$pro),n=M4)[1])Key_w_G# キーアイテム集合Key_w_I <- subset(Key_w,Key_w$pro>=tail(sort(Key_w$pro),n=M5)[1])Key_w_I# キーアイテム	