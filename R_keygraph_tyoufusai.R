demo<-function(M1,M2,M3,M4,M5) {library(RMeCab)library(twitteR)library(igraph)searchword <- readline("検索ワード : ")#Twitterのデータをあつめるtwitterword <-searchTwitter(searchword, n = 200)output <- searchwordoutputs <- as.data.frame(output)for (n in 1:200) { 	output <- twitterword[n][[1]]$text	if(nchar(charmatch("RT @",output)) == 1){next}	print(output)	tweet <- as.data.frame(output)	outputs <- rbind(outputs,tweet)}write.table(outputs,"output.txt",append=F, quote=F, col.names=F)# 下準備textdata <- "output.txt"# テキストデータ。ルート指定しないなら、Rのパス上に置く必要ある。文字コードUTF-8の改行コードLF。#M1 <- 30# 上位M1以内の単語#M2 <- 30# 共起度の実線#M3 <- 20# 橋の数#M4 <- 20# キーアイテム集合#M5 <- 5# キーアイテム# データ洗浄text <-  RMeCabFreq(textdata)# 読み込み、解析。頻度表を作成。text_temp <- text[text$Info1 =="名詞" & text$Info2 == "一般" |text$Info1 =="動詞" & text$Info2 == "自立" |text$Info1 =="形容詞" & text$Info2 == "自立",]# 抽出できた。抽出条件もひとまず。これで。text_temp <- text_temp[text_temp$Term!="する"&text_temp$Term!="いる"&text_temp$Term!="いう"&text_temp$Term!="できる"&text_temp$Term!="なる"&text_temp$Term !="ない"&text_temp$Term!="言う"&text_temp$Term!="ある"&text_temp$Term!="いい"&text_temp$Term!="やる"&text_temp$Term!="思う"&text_temp$Term!="人"&text_temp$Term!="ば"&text_temp$Term!="http"&text_temp$Term!="ー",]# text_temp <- text_temp[text_temp$Term!=searchword,]# 抽出ブラックリスト。するとか、なるとか。いるとか。ひとまず。# 共起グラフの作成text_freq <- subset(text_temp,text_temp$Freq>=tail(sort(text_temp$Freq),n=M1)[1])# tail(text_temp[order(text_temp$Freq),],n=20)から変更。これで上位定数位より上を抽出可能に。# これがM1text_w <- text_temp[,1] # 橋の形成で使用。print(text_freq[,1])top_text_freq <- text_freq[,1]# top_text_freqは文字列ベクトル。top_text_freq[1]は文字。# for 1からlength(top_text_freq)までループ1word_n <- 0kyoukiG <- 0for (n in 1:length(top_text_freq)) {	print(top_text_freq[n])	word_n <- as.data.frame(collocate(textdata,node=top_text_freq[n],span=5)[c(T,F,F,T,F)])	# print(top_text_freq[n])	# たとえばだけど、spanを1から「。」がBefore Afterで2個出てくるまでループさせるとか・・・。	# word_nはテキスト全部とある単語の共起度一覧。スパン5は変わらず。どうにかしないと。ココ。	word_m <- 0	# word_mをリセット	for (m in 1:length(top_text_freq)) {		# for 1からlength(top_text_freq)までループ2		word_meros <- word_n[word_n$Term==top_text_freq[m],]		# top_text_freq[m]を抽出word_meros関数を別の名前に		if(top_text_freq[n] == top_text_freq[m]){next}		if(length(word_meros$Span) == 0){next}		# ココでT,F判別。nとmが同じなら次のループへ。また、共起度あるなら下、次のループへ。長さ判別で0のやつをnextに持っていく。		word_m <- rbind(word_m,word_meros)		# word_merosをrbind関数でつなげる。	}	# ループ2ここまで	if(length(word_m) == 1){next}	# word_mに共起度が存在しない場合、次のループへ。	word_m$Term0<-top_text_freq[n]	# Term0を追加	word_m <- word_m[,c(3,1,2)]	# Term0 Term Spanの順番に	# グラフで描写出来るようにデータを整理。	kyoukiG <- rbind(kyoukiG,word_m)	# kyoukiG <- rbindでword_mをまた結合祭り。}# ループ1ここまでkyoukiGX <- 0for (n in 1:length(top_text_freq)) { 	kyoukiGX <- rbind(kyoukiG[kyoukiG$Term0 == top_text_freq[n],],kyoukiGX)	kyoukiG <- kyoukiG[kyoukiG$Term != top_text_freq[n] | kyoukiG$Term0 == top_text_freq[n],]}kyoukiG <- kyoukiGX[kyoukiGX$Span>0,]# 重複は抜く。kyoukiG[order(kyoukiG$Span),]kyoukiG <- subset(kyoukiG,kyoukiG$Span>=tail(sort(kyoukiG$Span),n=M2)[1])# これがM2。kyoukiGgraphdata_K<-graph.data.frame(kyoukiG, directed = F)E(graphdata_K)$width <- 2# 線の幅E(graphdata_K)$lty <- 1# 実線V(graphdata_K)$size <- 5V(graphdata_K)$label.cex <- 0.7V(graphdata_K)$label.color <- "black"V(graphdata_K)$label.dist <- 0.5V(graphdata_K)$label.degree <- pi/2V(graphdata_K)$color <- "skyblue"plot(graphdata_K, vertex.label=V(graphdata_K)$name)## 共起グラフをプロットしてみる。# 単連結削除	for (n in 1:length(kyoukiG$Span)) { 	# ループ開始	kyoukiGX <- kyoukiG[kyoukiG$Term0 != kyoukiG[n,1] | kyoukiG$Term != kyoukiG[n,2],]	# まず、2つの線を外してみる	if(length(kyoukiGX[kyoukiGX$Term0 == kyoukiG[n,1]|kyoukiGX$Term == kyoukiG[n,1],]$Span)==0){		kyoukiG[kyoukiG$Term0 == kyoukiG[n,1]&kyoukiG$Term == kyoukiG[n,2],]$Span <- 0		next	}	if(length(kyoukiGX[kyoukiGX$Term0 == kyoukiG[n,2]|kyoukiGX$Term == kyoukiG[n,2],]$Span)==0){		kyoukiG[kyoukiG$Term0 == kyoukiG[n,1]&kyoukiG$Term == kyoukiG[n,2],]$Span <- 0		next	}	# 消した文章あるかどうか。つまり、どちらかが0ならそこの組み合わせの共起度を0にして、次へ。	graphdata<-graph.data.frame(kyoukiGX, directed = F)	# 変換。データ処理。	# plot(graphdata, vertex.label=V(graphdata)$name)	# ↑これ見てると面白い。	if(length(get.all.shortest.paths(graphdata,kyoukiG[n,1],to = kyoukiG[n,2])[[1]])==0){		kyoukiG[kyoukiG$Term0 == kyoukiG[n,1]&kyoukiG$Term == kyoukiG[n,2],]$Span <- 0		next	}	# 1:存在する 0:存在しない		# 道はあるかどうかなかったらそこの組み合わせの共起度を0にしてつぎへ。}kyoukiGX <- kyoukiG[kyoukiG$Span>0,]kyoukiGX# 島graphdata_T<-graph.data.frame(kyoukiGX, directed = F)E(graphdata_T)$width <- 2# 線の幅E(graphdata_T)$lty <- 1# 実線V(graphdata_T)$size <- 5V(graphdata_T)$label.cex <- 0.7V(graphdata_T)$label.color <- "black"V(graphdata_T)$label.dist <- 0.5V(graphdata_T)$label.degree <- pi/2V(graphdata_T)$color <- "skyblue"plot(graphdata_T, vertex.label=V(graphdata_T)$name)## 単連結削除した共起グラフをプロットしてみる。	island_g <- union(kyoukiGX$Term0,kyoukiGX$Term)island_g# これが各島g# 橋の形成。# 島gとすべての単語wに対する共起度を測定。word_n <- 0kyoukiGW <- 0for (n in 1:length(island_g)) {	word_n <- as.data.frame(collocate(textdata,node=island_g[n],span=5)[c(T,F,F,T,F)])	# word_nはテキスト全部とある単語(島)の共起度一覧。スパン5は変わらず。どうにかしないと。ココ。	word_m <- 0	# word_mをリセット	for (m in 1:length(text_w)) {		# for 1からlength(text_w)までループ2		word_meros <- word_n[word_n$Term==text_w[m],]		# text_w[m]を抽出word_meros関数を別の名前に		if(island_g[n] == text_w[m]){next}		if(length(word_meros$Span) == 0){next}		# ココでT,F判別。nとmが同じなら次のループへ。また、共起度あるなら下、次のループへ。長さ判別で0のやつをnextに持っていく。		word_m <- rbind(word_m,word_meros)		# word_merosをrbind関数でつなげる。	}	# ループ2ここまで	if(length(word_m) == 1){next}	# word_mに共起度が存在しない場合、次のループへ。	word_m$Term0<-island_g[n]	# Term0を追加	word_m <- word_m[,c(3,1,2)]	# Term0 Term Spanの順番に	# グラフで描写出来るようにデータを整理。	kyoukiGW <- rbind(kyoukiGW,word_m)	# kyoukiGW <- rbindでword_mをまた結合祭り。}# ループ1ここまでkyoukiGWX <- 0for (n in 1:length(island_g)) { 	kyoukiGWX <- rbind(kyoukiGW[kyoukiGW$Term0 == island_g[n],],kyoukiGWX)	kyoukiGW <- kyoukiGW[kyoukiGW$Term != island_g[n] | kyoukiGW$Term0 == island_g[n],]}kyoukiGW <- kyoukiGWX[kyoukiGWX$Span>0,]# 重複を削除。kyoukiGW <- subset(kyoukiGW,kyoukiGW$Span>=tail(sort(kyoukiGW$Span),n=M3)[1])# tail(kyoukiGW[order(kyoukiGW$Span),],n=10)# これがM3の橋。kyoukiGXkyoukiGW# やっぱりマージはする必要あり?。だって上位M3位のなかに島が入るとは限らない。まあ、それは後で。# Key(w)作り。# 橋を介して w と結ばれる全ての島 g との共起度の和を Key(w) とする。item_w <- union(kyoukiGW$Term0,kyoukiGW$Term)item_w# これとすべての島island_gとの共起度を測定# n<-1Key_w <- data.frame(word="word",pro=0)for (n in 1:length(item_w)) { 	item_wX <- 0	pro_w <- 1	item_wX <- rbind(kyoukiGW[kyoukiGW$Term0 == item_w[n],] , kyoukiGW[kyoukiGW$Term == item_w[n],])	for(m in 1:length(island_g)) { 		# 各島		if(island_g[m] == item_w[n]){next}		if(length(item_wX[item_wX$Term0 == island_g[m],]$Span)==1){			probability_w <- 1 - item_wX[item_wX$Term0 == island_g[m],]$Span/text_temp[text_temp$Term == island_g[m],]$Freq			pro_w <- pro_w*probability_w		}		if(length(item_wX[item_wX$Term == island_g[m],]$Span)==1){			probability_w <- 1 - item_wX[item_wX$Term == island_g[m],]$Span/text_temp[text_temp$Term == island_g[m],]$Freq			pro_w <- pro_w*probability_w		}	}	pro_w <- 1- pro_w	key_wX <- data.frame(word=item_w[n],pro=pro_w)	Key_w <- rbind(Key_w,key_wX)}Key_w <- Key_w[Key_w$pro>0,]Key_wKey_w_G <- subset(Key_w,Key_w$pro>=tail(sort(Key_w$pro),n=M4)[1])Key_w_G# キーアイテム集合Key_w_G_hub <- Key_w_Gfor (n in 1:length(island_g)) { 	# ハブの抽出	Key_w_G_hub <- Key_w_G_hub[Key_w_G_hub$word != island_g[n],]}Key_w_G_hub# ハブKey_w_I <- subset(Key_w,Key_w$pro>=tail(sort(Key_w$pro),n=M5)[1])Key_w_I# キーアイテム	# プロットprint(kyoukiGX) # 島 太いprint(kyoukiGW) # 橋 細いprint(Key_w_G) # キーアイテム集合print(Key_w_G_hub) # ハブ 灰色print(Key_w_I) # キーアイテム 赤色kyoukiGX$Span <- 5kyoukiGW$Span <- 3# 橋優先for (n in 1:length(kyoukiGW$Span)) { 	kyoukiGX <- kyoukiGX[kyoukiGX$Term0 != kyoukiGW[[1]][n]|kyoukiGX$Term != kyoukiGW[[2]][n],]	kyoukiGX <- kyoukiGX[kyoukiGX$Term != kyoukiGW[[1]][n]|kyoukiGX$Term0 != kyoukiGW[[2]][n],]}keygraph <- merge(kyoukiGX,kyoukiGW,all=T)g <-graph.data.frame(keygraph, directed = F)# E(g)$color <- "black"E(g)[Span == 3]$width <- 2# 線の幅E(g)$lty <- 1# 実線E(g)[Span == 3]$lty <- 3# E(g)[Span == 3]$color <- "red"# 点線V(g)$size <- 5V(g)$label.cex <- 0.7V(g)$label.color <- "black"V(g)$label.dist <- 0.5V(g)$label.degree <- pi/2V(g)$color <- "skyblue"for(n in 1:length(Key_w_G_hub$word)){	V(g)[name == Key_w_G_hub$word[n]]$color <- "grey"}for(n in 1:length(Key_w_I$word)){	V(g)[name == Key_w_I$word[n]]$color <- "red"}# 色plot(g,layout=layout.auto ,vertex.label=V(g)$name)}